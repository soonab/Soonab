// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  // Pooled (PgBouncer) for runtime
  url               = env("DATABASE_URL")
  // Direct connection for migrate/deploy
  directUrl         = env("DATABASE_DIRECT_URL")
  // Shadow DB (must be non-pooled host) for migrate dev
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/// *
//  * Users & Profiles (Step-5)
model User {
  id        String       @id @default(cuid())
  email     String       @unique
  createdAt DateTime     @default(now())
  accounts  Account[]
  logins    LoginEvent[]
  profiles  Profile[]
}

model Profile {
  id                   String             @id @default(cuid())
  userId               String
  handle               String             @unique
  displayName          String?
  bio                  String?
  bioVisibility        Visibility         @default(PUBLIC)
  location             String?
  locationVisibility   Visibility         @default(PUBLIC)
  isDeleted            Boolean            @default(false)
  createdAt            DateTime           @default(now())
  followingConnections Follow[]           @relation("follows_follower")
  followerConnections  Follow[]           @relation("follows_following")
  posts                Post[]
  media                Media[]
  links                ProfileLink[]
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  penalties            ProfilePenalty[]
  replies              Reply[]
  raterProfileRatings  ReputationRating[] @relation("RaterProfileRatings")
  targetProfileRatings ReputationRating[] @relation("TargetProfileRatings")
  score                ReputationScore?
  trustReceived        Trust[]            @relation("trusts_trustee")
  trustGiven           Trust[]            @relation("trusts_truster")
  orgVerifications     OrgVerification[]
  conversationsAsA     Conversation[]     @relation("ConversationMemberA")
  conversationsAsB     Conversation[]     @relation("ConversationMemberB")
  conversationsCreated Conversation[]     @relation("ConversationCreatedBy")
  messagesSent         Message[]
  dmBlocksInitiated    DMBlock[]          @relation("DMBlocker")
  dmBlocksReceived     DMBlock[]          @relation("DMBlocked")
}

/// *
//  * Magic link tokens
model MagicLinkToken {
  id        String    @id @default(cuid())
  email     String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([email, expiresAt])
}

/// *
//  * Setup marker
model SetupCheck {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
}

/// *
//  * Posts & Replies
model Post {
  id         String       @id @default(cuid())
  sessionId  String?
  body       String
  createdAt  DateTime     @default(now())
  visibility Visibility   @default(PUBLIC)
  profileId  String?
  state      ContentState @default(ACTIVE)
  spaceId    String?
  profile    Profile?     @relation(fields: [profileId], references: [id])
  space      Space?       @relation(fields: [spaceId], references: [id])
  replies    Reply[]
  tags       PostTag[]
  media      PostMedia[]

  @@index([createdAt(sort: Desc)])
  @@index([profileId, createdAt(sort: Desc)])
  @@index([state, createdAt(sort: Desc)])

  // Composite unique used for deterministic chrono cursors.
  // Alias `createdAt_id` is referenced in Prisma Client queries.
  @@unique([createdAt, id], name: "createdAt_id", map: "uq_post_created_id")

  // Space feed index (filter + order). The unique above already backs ORDER BY.
  @@index([spaceId, createdAt, id], map: "idx_post_space_created_id")
}

model Reply {
  id         String       @id @default(cuid())
  postId     String
  sessionId  String?
  body       String
  createdAt  DateTime     @default(now())
  visibility Visibility   @default(PUBLIC)
  profileId  String?
  state      ContentState @default(ACTIVE)
  post       Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  profile    Profile?     @relation(fields: [profileId], references: [id])
  tags       ReplyTag[]

  @@index([profileId, createdAt(sort: Desc)])
  @@index([state, createdAt(sort: Desc)])
  @@index([postId, createdAt, id], map: "idx_reply_post_created_id_asc")
}

model Tag {
  id        String     @id @default(cuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  posts     PostTag[]
  replies   ReplyTag[]
}

model PostTag {
  postId String
  tagId  String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([tagId, postId])
}

model ReplyTag {
  replyId String
  tagId   String
  reply   Reply  @relation(fields: [replyId], references: [id], onDelete: Cascade)
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([replyId, tagId])
  @@index([tagId, replyId])
}

model ModerationReport {
  id         String       @id @default(cuid())
  sessionId  String?
  targetType ReportTarget
  targetId   String
  reason     String?
  createdAt  DateTime     @default(now())

  @@index([createdAt(sort: Desc)])
}

model ModerationAction {
  id         String               @id @default(cuid())
  actor      String
  targetType ModerationTarget
  targetId   String?
  profileId  String?
  action     ModerationActionType
  reason     String?
  createdAt  DateTime             @default(now())

  @@index([createdAt(sort: Desc)])
  @@index([targetType, targetId, createdAt(sort: Desc)])
}

model ProfilePenalty {
  id         String      @id @default(cuid())
  profileId  String
  kind       PenaltyKind
  until      DateTime?
  reason     String?
  createdAt  DateTime    @default(now())
  resolvedAt DateTime?
  profile    Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId, createdAt(sort: Desc)])
  @@index([until])
}

/// *
//  * Pseudonymous session profile (pre-accounts)
model SessionProfile {
  id            String             @id @default(cuid())
  sessionId     String             @unique
  handle        String             @unique
  createdAt     DateTime           @default(now())
  raterRatings  ReputationRating[] @relation("RaterRatings")
  targetRatings ReputationRating[] @relation("TargetRatings")
}

/// *
//  * Ratings (support session- and profile-based IDs)
model ReputationRating {
  id              String          @id @default(cuid())
  targetSessionId String?
  raterSessionId  String?
  value           Int
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  raterProfileId  String?
  targetProfileId String?
  raterProfile    Profile?        @relation("RaterProfileRatings", fields: [raterProfileId], references: [id])
  raterSession    SessionProfile? @relation("RaterRatings", fields: [raterSessionId], references: [sessionId])
  targetProfile   Profile?        @relation("TargetProfileRatings", fields: [targetProfileId], references: [id])
  targetSession   SessionProfile? @relation("TargetRatings", fields: [targetSessionId], references: [sessionId])

  @@unique([targetSessionId, raterSessionId], name: "one_rater_per_target_session")
  @@unique([targetProfileId, raterProfileId], name: "one_rater_per_target_profile")
  @@index([raterSessionId, updatedAt], map: "idx_reputation_rater_updated")
  @@index([targetSessionId, updatedAt], map: "idx_reputation_target_updated")
  @@index([raterProfileId, updatedAt], map: "idx_reputation_rater_profile_updated")
  @@index([targetProfileId, updatedAt], map: "idx_reputation_target_profile_updated")
}

/// *
//  * Cached aggregates
model ReputationScore {
  sessionId    String   @id
  count        Int      @default(0)
  sum          Int      @default(0)
  mean         Float    @default(0)
  bayesianMean Float    @default(0)
  updatedAt    DateTime @updatedAt
  profileId    String?  @unique
  profile      Profile? @relation(fields: [profileId], references: [id])
}

/// *
//  * Step-4 suspicion flags
model ReputationFlag {
  id              String   @id @default(cuid())
  targetSessionId String
  windowStart     DateTime
  windowEnd       DateTime
  reason          String
  count           Int
  resolved        Boolean  @default(false)
  createdAt       DateTime @default(now())

  @@index([createdAt(sort: Desc)])
  @@index([targetSessionId, createdAt(sort: Desc)])
}

/// *
//  * Step-6 audience edges
model Follow {
  followerProfileId  String
  followingProfileId String
  createdAt          DateTime @default(now())
  follower           Profile  @relation("follows_follower", fields: [followerProfileId], references: [id], onDelete: Cascade)
  following          Profile  @relation("follows_following", fields: [followingProfileId], references: [id], onDelete: Cascade)

  @@id([followerProfileId, followingProfileId])
  @@index([followingProfileId, followerProfileId])
  @@index([createdAt(sort: Desc)])
}

model Trust {
  trusterProfileId String
  trusteeProfileId String
  createdAt        DateTime @default(now())
  trustee          Profile  @relation("trusts_trustee", fields: [trusteeProfileId], references: [id], onDelete: Cascade)
  truster          Profile  @relation("trusts_truster", fields: [trusterProfileId], references: [id], onDelete: Cascade)

  @@id([trusterProfileId, trusteeProfileId])
  @@index([trusteeProfileId, trusterProfileId])
  @@index([createdAt(sort: Desc)])
}

/// *
//  * Step-12 — Direct Messages (text-only, 1:1)
enum ConversationStatus {
  PENDING
  ACTIVE
  BLOCKED
}

model Conversation {
  id            String             @id @default(cuid())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  memberAId     String
  memberBId     String
  createdById   String
  status        ConversationStatus @default(PENDING)
  lastMessageAt DateTime?

  memberA   Profile   @relation("ConversationMemberA", fields: [memberAId], references: [id])
  memberB   Profile   @relation("ConversationMemberB", fields: [memberBId], references: [id])
  createdBy Profile   @relation("ConversationCreatedBy", fields: [createdById], references: [id])
  messages  Message[]
  blocks    DMBlock[]

  @@unique([memberAId, memberBId])
  @@index([lastMessageAt, id])
}

model Message {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  conversationId String
  senderId       String
  body           String   @db.Text

  conversation Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       Profile          @relation(fields: [senderId], references: [id])
  media        DMMessageMedia[]

  @@index([conversationId, createdAt, id])
}

model DMBlock {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  blockerId      String
  blockedId      String
  conversationId String

  blocker      Profile      @relation("DMBlocker", fields: [blockerId], references: [id])
  blocked      Profile      @relation("DMBlocked", fields: [blockedId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId, conversationId])
}

model Account {
  id         String       @id @default(cuid())
  userId     String
  provider   AuthProvider
  providerId String
  email      String?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([userId])
}

model LoginEvent {
  id        String      @id @default(cuid())
  userId    String
  method    LoginMethod
  ip        String?
  userAgent String?
  createdAt DateTime    @default(now())
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
}

model OAuthState {
  id           String    @id @default(cuid())
  state        String    @unique
  codeVerifier String
  nonce        String
  sessionId    String?
  redirectTo   String?
  createdAt    DateTime  @default(now())
  usedAt       DateTime?
  expiresAt    DateTime

  @@index([expiresAt])
}

/// === Step 14: Profile fields & verification ===

model ProfileLink {
  id         String     @id @default(cuid())
  profileId  String
  profile    Profile    @relation(fields: [profileId], references: [id], onDelete: Cascade)
  title      String
  url        String
  order      Int        @default(0)
  visibility Visibility @default(PUBLIC)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@index([profileId, order])
}

model OrgVerification {
  id         String          @id @default(cuid())
  profileId  String
  profile    Profile         @relation(fields: [profileId], references: [id], onDelete: Cascade)
  orgName    String
  domain     String
  status     OrgVerifyStatus @default(PENDING)
  method     OrgVerifyMethod @default(EMAIL_DOMAIN)
  createdAt  DateTime        @default(now())
  verifiedAt DateTime?
}

model Space {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?
  createdById String
  createdAt   DateTime @default(now())

  createdBy   Profile  @relation(fields: [createdById], references: [id])
  members     SpaceMembership[]
  posts       Post[]

  @@index([createdAt])
}

model SpaceMembership {
  id        String   @id @default(cuid())
  spaceId   String
  profileId String
  role      String   // 'member' | 'moderator' | 'owner'
  createdAt DateTime @default(now())

  space     Space    @relation(fields: [spaceId], references: [id])
  profile   Profile  @relation(fields: [profileId], references: [id])

  @@unique([spaceId, profileId])
  @@index([profileId])
}

model Collection {
  id         String     @id @default(cuid())
  slug       String     @unique
  title      String
  ownerId    String
  visibility Visibility @default(PUBLIC)
  createdAt  DateTime   @default(now())

  owner      Profile    @relation(fields: [ownerId], references: [id])
  entries    CollectionEntry[]
}

model CollectionEntry {
  id           String   @id @default(cuid())
  collectionId String
  postId       String
  addedAt      DateTime @default(now())

  collection   Collection @relation(fields: [collectionId], references: [id])
  post         Post       @relation(fields: [postId], references: [id])

  @@unique([collectionId, postId])
  @@index([addedAt])
}

enum OrgVerifyStatus {
  PENDING
  VERIFIED
  REVOKED
}

enum OrgVerifyMethod {
  EMAIL_DOMAIN
  MANUAL
}

/// *
//  * Visibility & Content State
enum Visibility {
  PUBLIC
  FOLLOWERS
  TRUSTED
}

enum ContentState {
  ACTIVE
  HIDDEN
  REMOVED
}

/// *
//  * Moderation — reports, actions, penalties
enum ReportTarget {
  POST
  REPLY
}

enum ModerationActionType {
  HIDE
  UNHIDE
  REMOVE
  BLOCK_PROFILE
  UNBLOCK_PROFILE
  FLAG
}

enum ModerationTarget {
  POST
  REPLY
  PROFILE
  CONVERSATION
  MESSAGE
}

model Media {
  id             String           @id @default(cuid())
  ownerProfileId String
  kind           MediaKind        @default(IMAGE)
  status         MediaStatus      @default(UPLOADING)
  ext            String
  contentType    String
  sizeBytes      Int
  width          Int?
  height         Int?
  variants       MediaVariant[]
  posts          PostMedia[]
  messages       DMMessageMedia[]
  createdAt      DateTime         @default(now())
  deletedAt      DateTime?
  ownerProfile   Profile          @relation(fields: [ownerProfileId], references: [id])

  @@index([ownerProfileId, createdAt])
}

model MediaVariant {
  id          String      @id @default(cuid())
  mediaId     String
  media       Media       @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  role        VariantRole
  key         String      @unique
  width       Int
  height      Int
  sizeBytes   Int
  contentType String
  createdAt   DateTime    @default(now())
}

model PostMedia {
  postId  String
  mediaId String
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  media   Media  @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@id([postId, mediaId])
}

model DMMessageMedia {
  messageId String
  mediaId   String
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  media     Media   @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@id([messageId, mediaId])
}

enum MediaKind {
  IMAGE
}

enum MediaStatus {
  UPLOADING
  READY
  DELETING
  DELETED
}

enum VariantRole {
  ORIGINAL
  LARGE
  THUMB
}

enum PenaltyKind {
  TEMP_POST_BAN
  PERMA_BAN
}

/// *
//  * Step-8 — Google OAuth v1
enum AuthProvider {
  GOOGLE
}

enum LoginMethod {
  MAGIC_LINK
  GOOGLE
}

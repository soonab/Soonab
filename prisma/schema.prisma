generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// *
///  * Users & Profiles (Step-5)
model User {
  id        String       @id @default(cuid())
  email     String       @unique
  createdAt DateTime     @default(now())
  accounts  Account[]
  logins    LoginEvent[]
  profiles  Profile[]
}

model Profile {
  id                   String             @id @default(cuid())
  userId               String
  handle               String             @unique
  displayName          String?
  bio                  String?
  isDeleted            Boolean            @default(false)
  createdAt            DateTime           @default(now())
  followingConnections Follow[]           @relation("follows_follower")
  followerConnections  Follow[]           @relation("follows_following")
  posts                Post[]
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  penalties            ProfilePenalty[]
  replies              Reply[]
  raterProfileRatings  ReputationRating[] @relation("RaterProfileRatings")
  targetProfileRatings ReputationRating[] @relation("TargetProfileRatings")
  score                ReputationScore?
  trustReceived        Trust[]            @relation("trusts_trustee")
  trustGiven           Trust[]            @relation("trusts_truster")
  conversationsAsA     Conversation[]     @relation("ConversationMemberA")
  conversationsAsB     Conversation[]     @relation("ConversationMemberB")
  conversationsCreated Conversation[]     @relation("ConversationCreatedBy")
  messagesSent         Message[]
  dmBlocksInitiated    DMBlock[]          @relation("DMBlocker")
  dmBlocksReceived     DMBlock[]          @relation("DMBlocked")
}

/// *
///  * Magic link tokens
model MagicLinkToken {
  id        String    @id @default(cuid())
  email     String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([email, expiresAt])
}

/// *
///  * Setup marker
model SetupCheck {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
}

/// *
///  * Posts & Replies
model Post {
  id         String       @id @default(cuid())
  sessionId  String?
  body       String
  createdAt  DateTime     @default(now())
  visibility Visibility   @default(PUBLIC)
  profileId  String?
  state      ContentState @default(ACTIVE)
  profile    Profile?     @relation(fields: [profileId], references: [id])
  replies    Reply[]
  tags       PostTag[]

  @@index([createdAt(sort: Desc)])
  @@index([profileId, createdAt(sort: Desc)])
  @@index([state, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc), id(sort: Desc)], map: "idx_post_created_id_desc")
}

model Reply {
  id         String       @id @default(cuid())
  postId     String
  sessionId  String?
  body       String
  createdAt  DateTime     @default(now())
  visibility Visibility   @default(PUBLIC)
  profileId  String?
  state      ContentState @default(ACTIVE)
  post       Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  profile    Profile?     @relation(fields: [profileId], references: [id])
  tags       ReplyTag[]

  @@index([profileId, createdAt(sort: Desc)])
  @@index([state, createdAt(sort: Desc)])
  @@index([postId, createdAt, id], map: "idx_reply_post_created_id_asc")
}

model Tag {
  id        String     @id @default(cuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  posts     PostTag[]
  replies   ReplyTag[]
}

model PostTag {
  postId String
  tagId  String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([tagId, postId])
}

model ReplyTag {
  replyId String
  tagId   String
  reply   Reply  @relation(fields: [replyId], references: [id], onDelete: Cascade)
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([replyId, tagId])
  @@index([tagId, replyId])
}

model ModerationReport {
  id         String       @id @default(cuid())
  sessionId  String?
  targetType ReportTarget
  targetId   String
  reason     String?
  createdAt  DateTime     @default(now())

  @@index([createdAt(sort: Desc)])
}

model ModerationAction {
  id         String               @id @default(cuid())
  actor      String
  targetType ModerationTarget
  targetId   String?
  profileId  String?
  action     ModerationActionType
  reason     String?
  createdAt  DateTime             @default(now())

  @@index([createdAt(sort: Desc)])
  @@index([targetType, targetId, createdAt(sort: Desc)])
}

model ProfilePenalty {
  id         String      @id @default(cuid())
  profileId  String
  kind       PenaltyKind
  until      DateTime?
  reason     String?
  createdAt  DateTime    @default(now())
  resolvedAt DateTime?
  profile    Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId, createdAt(sort: Desc)])
  @@index([until])
}

/// *
///  * Pseudonymous session profile (pre-accounts)
model SessionProfile {
  id            String             @id @default(cuid())
  sessionId     String             @unique
  handle        String             @unique
  createdAt     DateTime           @default(now())
  raterRatings  ReputationRating[] @relation("RaterRatings")
  targetRatings ReputationRating[] @relation("TargetRatings")
}

/// *
///  * Ratings (support session- and profile-based IDs)
model ReputationRating {
  id              String          @id @default(cuid())
  targetSessionId String?
  raterSessionId  String?
  value           Int
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  raterProfileId  String?
  targetProfileId String?
  raterProfile    Profile?        @relation("RaterProfileRatings", fields: [raterProfileId], references: [id])
  raterSession    SessionProfile? @relation("RaterRatings", fields: [raterSessionId], references: [sessionId])
  targetProfile   Profile?        @relation("TargetProfileRatings", fields: [targetProfileId], references: [id])
  targetSession   SessionProfile? @relation("TargetRatings", fields: [targetSessionId], references: [sessionId])

  @@unique([targetSessionId, raterSessionId], name: "one_rater_per_target_session")
  @@unique([targetProfileId, raterProfileId], name: "one_rater_per_target_profile")
  @@index([raterSessionId, updatedAt], map: "idx_reputation_rater_updated")
  @@index([targetSessionId, updatedAt], map: "idx_reputation_target_updated")
  @@index([raterProfileId, updatedAt], map: "idx_reputation_rater_profile_updated")
  @@index([targetProfileId, updatedAt], map: "idx_reputation_target_profile_updated")
}

/// *
///  * Cached aggregates
model ReputationScore {
  sessionId    String   @id
  count        Int      @default(0)
  sum          Int      @default(0)
  mean         Float    @default(0)
  bayesianMean Float    @default(0)
  updatedAt    DateTime @updatedAt
  profileId    String?  @unique
  profile      Profile? @relation(fields: [profileId], references: [id])
}

/// *
///  * Step-4 suspicion flags
model ReputationFlag {
  id              String   @id @default(cuid())
  targetSessionId String
  windowStart     DateTime
  windowEnd       DateTime
  reason          String
  count           Int
  resolved        Boolean  @default(false)
  createdAt       DateTime @default(now())

  @@index([createdAt(sort: Desc)])
  @@index([targetSessionId, createdAt(sort: Desc)])
}

/// *
///  * Step-6 audience edges
model Follow {
  followerProfileId  String
  followingProfileId String
  createdAt          DateTime @default(now())
  follower           Profile  @relation("follows_follower", fields: [followerProfileId], references: [id], onDelete: Cascade)
  following          Profile  @relation("follows_following", fields: [followingProfileId], references: [id], onDelete: Cascade)

  @@id([followerProfileId, followingProfileId])
  @@index([followingProfileId, followerProfileId])
  @@index([createdAt(sort: Desc)])
}

model Trust {
  trusterProfileId String
  trusteeProfileId String
  createdAt        DateTime @default(now())
  trustee          Profile  @relation("trusts_trustee", fields: [trusteeProfileId], references: [id], onDelete: Cascade)
  truster          Profile  @relation("trusts_truster", fields: [trusterProfileId], references: [id], onDelete: Cascade)

  @@id([trusterProfileId, trusteeProfileId])
  @@index([trusteeProfileId, trusterProfileId])
  @@index([createdAt(sort: Desc)])
}

/// *
///  * Step-12 — Direct Messages (text-only, 1:1)
enum ConversationStatus {
  PENDING
  ACTIVE
  BLOCKED
}

model Conversation {
  id            String             @id @default(cuid())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  memberAId     String
  memberBId     String
  createdById   String
  status        ConversationStatus @default(PENDING)
  lastMessageAt DateTime?

  memberA   Profile   @relation("ConversationMemberA", fields: [memberAId], references: [id])
  memberB   Profile   @relation("ConversationMemberB", fields: [memberBId], references: [id])
  createdBy Profile   @relation("ConversationCreatedBy", fields: [createdById], references: [id])
  messages  Message[]
  blocks    DMBlock[]

  @@unique([memberAId, memberBId])
  @@index([lastMessageAt, id])
}

model Message {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  conversationId String
  senderId       String
  body           String   @db.Text

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       Profile      @relation(fields: [senderId], references: [id])

  @@index([conversationId, createdAt, id])
}

model DMBlock {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  blockerId      String
  blockedId      String
  conversationId String

  blocker      Profile      @relation("DMBlocker", fields: [blockerId], references: [id])
  blocked      Profile      @relation("DMBlocked", fields: [blockedId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId, conversationId])
}

model Account {
  id         String       @id @default(cuid())
  userId     String
  provider   AuthProvider
  providerId String
  email      String?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([userId])
}

model LoginEvent {
  id        String      @id @default(cuid())
  userId    String
  method    LoginMethod
  ip        String?
  userAgent String?
  createdAt DateTime    @default(now())
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
}

model OAuthState {
  id           String    @id @default(cuid())
  state        String    @unique
  codeVerifier String
  nonce        String
  sessionId    String?
  redirectTo   String?
  createdAt    DateTime  @default(now())
  usedAt       DateTime?
  expiresAt    DateTime

  @@index([expiresAt])
}

/// *
///  * Visibility & Content State
enum Visibility {
  PUBLIC
  FOLLOWERS
  TRUSTED
}

enum ContentState {
  ACTIVE
  HIDDEN
  REMOVED
}

/// *
///  * Moderation — reports, actions, penalties
enum ReportTarget {
  POST
  REPLY
}

enum ModerationActionType {
  HIDE
  UNHIDE
  REMOVE
  BLOCK_PROFILE
  UNBLOCK_PROFILE
  FLAG
}

enum ModerationTarget {
  POST
  REPLY
  PROFILE
  CONVERSATION
  MESSAGE
}

enum PenaltyKind {
  TEMP_POST_BAN
  PERMA_BAN
}

/// *
///  * Step-8 — Google OAuth v1
enum AuthProvider {
  GOOGLE
}

enum LoginMethod {
  MAGIC_LINK
  GOOGLE
}
